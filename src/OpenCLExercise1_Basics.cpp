//////////////////////////////////////////////////////////////////////////////
// OpenCL exercise 1: Basics
//////////////////////////////////////////////////////////////////////////////

// includes
#include <stdio.h>
#include <Core/Assert.hpp>
#include <Core/Time.hpp>
#include <OpenCL/cl-patched.hpp>
#include <OpenCL/Program.hpp>
#include <OpenCL/Event.hpp>
#include <OpenCL/Device.hpp>
#include <fstream>
#include <sstream>
#include <iostream>
#include <cmath>
#include <string>
#include <iomanip>
#include "openssl/sha.h"
#include "math.h"

using namespace std;

//global variable
long linecount = -1;					//initial count of line value
const int MAX_PW_LENGTH = 4;			//length of each password
char inputfile[] = "lalpha4.txt";		//filename for reading out the password
char outputGPU[] = "outputGPU.txt";		//filename for saving the hashed output of GPU
char outputCPU[] = "outputCPU.txt";		//filename for saving the hashed output of CPU


bool kernelExecutionInProgress = false;
int kernelExecuteCount = 0;
cl_int kernelExecStatus;

//initial timing event for GPU
cl::Event copy1;
cl::Event execution;
cl::Event copy2;

//initial timing variable for GPU
Core::TimeSpan copyTime(0);
Core::TimeSpan gpuTime(0);

//type definition for input
typedef struct {
	char word[MAX_PW_LENGTH];
} wordStruct;

//type definition for output
typedef struct {
	uint hash[8];
} outStruct;

/**
 * compareFile
 * compare the desired hash with hash value in file
 * @param filename		filename of the target file
 * @param hashToCrack	desired hash
 */
void compareFile(char* filename, string hashToCrack, string device){
	string currentpw;		//string to keep track of current password
	string currenthash;		//string to keep track of current hash
	bool notfound = false;
	//read from the file
	cout << "Reading from " << filename << " generated by "<< device << "..." << endl;
	ifstream examplefile;
	examplefile.open(filename, ios::in);

        //compare the desired hash to the current hash on file and display the result
	while (getline(examplefile, currentpw, '\t') && getline(examplefile, currenthash)) {
		if (currenthash.compare(hashToCrack) == 0) {
			cout << "Plaintext found on " << device << "!\t" << currentpw << ":" << currenthash << endl;
			cout << "PW = " << currentpw << endl<< endl;
			notfound = false;
			break;
		}
        else
        {
            notfound = true;
        }
	}
	if (notfound)
	{
    	cout << "Plaintext is not found on " << device << endl<< endl;
	}
	examplefile.close();
}

/**
 * compareOutputHash
 * compare the desired hash with output of device
 * @param input			vector of password
 * @param output		vector of computed hash value
 * @param hashToCrack	desired hash
 * @param device		the device which generated the vector of hash value
 * @return				true if find a match between computed hash and desired hash
 */
bool compareOutputHash(vector <wordStruct> &input,vector<outStruct> &output, string hashToCrack, string device) {
	string currentpw;
	stringstream ss;
	cout << "Comparing hashes with " << hashToCrack << " on " << device <<endl;
	cout << "///////////////////////////////////////////////////////////////////////////////////////////////////" << endl;
	for (int i = 0; i < output.size(); i++) {
		currentpw.clear();
		ss.str(string());

		//load the current password
		for (int k = 0; k < MAX_PW_LENGTH; k++) {
			currentpw += input[i].word[k];
		}

		//load the current computed hash from current password
		for (int j =0;j<8;j++){
		ss << std::uppercase << hex << setfill('0') << setw(8) << output[i].hash[j];
		}

		//if the current computed hash is equal to desired hash
		// print out the current password
		if (hashToCrack.compare(ss.str()) == 0) {
			cout << "Plaintext found on " << device << "!\t" << currentpw << ":" << ss.str() << endl;
			cout << "PW = " << currentpw << endl;
			cout << "///////////////////////////////////////////////////////////////////////////////////////////////////" << endl<< endl;
			return true;
		}
	}
	return false;
}

/**
 * outFile
 * write the password and hash value into file and return true if it finish writing to the file
 * @param filename	filename of the target file
 * @param input		password
 * @param count		number of line we want to write
 * @param output	hash
 * @return			true if finish writing to the file
 */
bool outFile(char* filename, vector<wordStruct> &input, size_t count,
		vector<outStruct> &output) {
	//create and open the output file with append mode
	ofstream out(filename, ios::app);
	cout << "Writing to file, please do not turn off the system!" << endl;
	for (size_t i = 0; i < count; i++) {
		//write the password to the file
		for (int j = 0; j < MAX_PW_LENGTH; j++) {
			out << input[i].word[j];
		}
		out << "\t";
		//write the hash value of the password to the file
		for (int j = 0; j < 8; j++) {
			out << std::uppercase << hex << setfill('0');
			out << setw(8) << output[i].hash[j];
		}
		out << endl;
	}
	out.close();
	return true;
}

/**
 * sha256GPU
 * copy the password to GPU, compute the hash, copy the hash back to host and return the hash
 * @param queue
 * @param kernel1		the created kernel
 * @param d_input		buffer for input
 * @param d_output		buffer for output
 * @param d_length		buffer for the length of each password
 * @param h_input		password input of the target kernel
 * @param h_length		length input of the target kernel
 * @param h_outputGpu	hash output of the target kernel
 * @param sizein		size of the password input
 * @param sizeout		size of the hash output
 * @param sizelength	size of the length input
 * @param wgSize		work group size
 * @param count			total work item per slice
 * @return				hash value of the password
 */
vector<outStruct> sha256GPU(cl::CommandQueue &queue,cl::Kernel &kernel1, cl::Buffer &d_input,
		cl::Buffer &d_output, cl::Buffer &d_length, vector<wordStruct> &h_input,
		vector<cl_int> &h_length, vector<outStruct> &h_outputGpu, size_t sizein,
		size_t sizeout, size_t sizelength, size_t wgSize, size_t count) {

	cout << "Writing Data to the GPU.." << endl;

	// Copy password input from host to GPU
	cl_int CL_ERRWB1 = queue.enqueueWriteBuffer(d_input, true, 0, sizein,
			h_input.data(), NULL, &copy1);

	// Check if the password inputs are successfully copied
	if (CL_ERRWB1 == CL_SUCCESS) {
		cout << "Passwords written" << endl;
	}

	// Copy length input from host to GPU
	cl_int CL_ERRWB2 = queue.enqueueWriteBuffer(d_length, true, 0, sizelength,
			h_length.data(),
			NULL, &copy1);

	// Check if the length inputs are successfully copied
	if (CL_ERRWB2 == CL_SUCCESS) {
		cout << "Length data written" << endl;
	}

	kernelExecuteCount++;
	kernelExecutionInProgress = true;

	cout << "Execute kernel, count: " << kernelExecuteCount << endl;

	// Launch kernel on the device
	kernelExecStatus = queue.enqueueNDRangeKernel(kernel1, 0, count, wgSize,
	NULL, &execution);

	//check if the kernel is successfully launched
	if (kernelExecStatus == CL_SUCCESS) {
		cout << "Kernel execution successfully completed" << endl;
	}

	// Read the output of GPU back to host
	queue.enqueueReadBuffer(d_output, CL_TRUE, 0, sizeout, h_outputGpu.data(),
	NULL, &copy2);

	// Calculate the timing per slice
	gpuTime = OpenCL::getElapsedTime(execution);
	Core::TimeSpan copyTime1 = OpenCL::getElapsedTime(copy1);
	Core::TimeSpan copyTime2 = OpenCL::getElapsedTime(copy2);
	copyTime = copyTime1 + copyTime2;

	return h_outputGpu;
}

//////////////////////////////////////////////////////////////////////////////
// CPU implementation
//////////////////////////////////////////////////////////////////////////////
/**
 * sha256
 * computed the hash value of password on the CPU using openssl/sha.h
 * @param input		password
 * @param count		number of password
 * @param output	hash
 * @return
 */
vector<outStruct> sha256(vector<wordStruct> &input, size_t count,
		vector<outStruct> &output) {
	uint W = 0x00000000;

	for (size_t i = 0; i < count; i++) {
		unsigned char digest[SHA256_DIGEST_LENGTH];
		int check = 0;
		char string[MAX_PW_LENGTH];

		//copy the input to a string
		for (int j = 0; j < MAX_PW_LENGTH; j++) {
			string[j] = (input[i].word[j]);
		}

		//do sha256 via openssl/sha.h
		SHA256_CTX ctx;
		SHA256_Init(&ctx);
		SHA256_Update(&ctx, string, MAX_PW_LENGTH);
		SHA256_Final(digest, &ctx);

		//rearrange the output format from openssl/sha.h to the desired structure
		for (int k = 0; k < 8; k++) {
			W = (digest[k * 4]) << 24;
			W |= (digest[k * 4 + 1]) << 16;
			W |= (digest[k * 4 + 2]) << 8;
			W |= (digest[k * 4 + 3]);
			output[i].hash[k] = W;
		}

	}

	cout << "Iteration finished on CPU" << endl;
	return output;
}

/**
 * readDataFromFile
 * read data line by line from the input file and store them into char array
 * @param line			parameter to store one line of the file
 * @param wordlist		register for all the line in file
 * @param count			number of line we want to store
 * @param countmin
 * @param countmax
 * @return
 */
char* readDataFromFile(char* line, char* wordlist, size_t count, long countmin,
		long countmax) {
	fstream wlfile;
	long countIt = -1;
	wlfile.open(inputfile, ios::in);
	wlfile.seekg(countmin * (MAX_PW_LENGTH + 1)); //MAX_PW_LENGTH+1 (5 chars + newline)
	printf("countmin: %ld\n", countmin);
	printf("countmax: %ld\n", countmax);
	while (!wlfile.eof()) {
		countIt++;
		if (countIt > (countmax - countmin - 1))
			break;
		wlfile.getline(line, sizeof(wlfile));
		for (int i = 0; i < MAX_PW_LENGTH; i++) {
			wordlist[countIt * MAX_PW_LENGTH + i] = line[i];
		}

	}
	wlfile.close();
	//cout<<"linecount: "<<linecount<<endl;
	return wordlist;
}
/**
 * countLine
 * count the number of line in the input file
 */
void countLine() {
	fstream myfile;
	string line;
	cout << "counting lines in file.." << endl;
	cout << "Please do not turn off the system!" << endl;
	myfile.open(inputfile, ios::in);

	if (myfile.is_open()) {
		while (!myfile.eof()) {
			getline(myfile, line);
			linecount++;
		}
		myfile.close();
		printf("\n# of line: %ld\n", linecount);
	}
}


//////////////////////////////////////////////////////////////////////////////
// Main function
//////////////////////////////////////////////////////////////////////////////
int main(int argc, char** argv) {
	bool hashNotCorrect = true;
	bool modeNotSet = true;
	bool diskModeNotSet = true;
	string hashToCrack;
	int GPUoverCPU = 2;
	bool saveOutputToDisk = false;
	int inputNumber;

	bool foundOnCPU = false;
	bool foundOnGPU = false;

	cout << "/////////////////////////////////////////////////////////////////////////////"<< endl;
	cout << "Welcome to SHA256 password recovery!" << endl;
	cout << "/////////////////////////////////////////////////////////////////////////////"<< endl;
	cout << "This tool helps users to recover passwords if the SHA256 hash is known"<< endl;
	cout << endl;

	//ask for desired hash to crack and
	//check if the hashed enter by user is correct, with 64 characters
	while (hashNotCorrect) {
		cout << "Please enter the desired SHA256 hash:" << endl;
		getline(cin, hashToCrack);
		if (hashToCrack.length() != 64) {
			cout << "Enter a valid SHA256 hash!" << endl;
		} else {
			hashNotCorrect = false;
		}
	}
	cout << endl;
	cout << hashToCrack << " is the SHA256 hash to be used." << endl << endl;

	//user select the device to calculate the hash and
	//check if the input is valid
	cout << "Type '0' for CPU or '1' for GPU use." << endl;
	cout << "Type '2' to use the CPU as well as the GPU and compare the results:" << endl;
	while (modeNotSet) {
		cin.clear();
		cin >> GPUoverCPU;
		if (cin && (GPUoverCPU == 0 || GPUoverCPU == 1 || GPUoverCPU == 2)) {
			modeNotSet = false;
			if (GPUoverCPU == 0) {
				cout << "System will use the CPU to get the plaintext." << endl;
			} else if (GPUoverCPU == 1) {
				cout << "System will use the GPU to get the plaintext." << endl;
			} else {
				cout << "System will use both CPU and the GPU to get the plaintext and compare results." << endl << endl << endl;
			}
		} else {
			cout << "Type either '0', '1' or '2':" << endl;
			cin.clear();
		}

	}

	//user select if the computed hashes are saved to disk or not
	//check if the input is valid
	while(diskModeNotSet) {
		cout << "Should all the computed hashes be saved to disk?" << endl;
		cout << "Type '0' for saving all computed hashes to disk or '1' for directly comparing computed hashes" << endl;
		cin.clear();
		cin >> inputNumber;
		if (cin && (inputNumber == 0 || inputNumber == 1))
		{
			if(inputNumber == 0){
				saveOutputToDisk = true;
				diskModeNotSet = false;
				cout<< "System will save all computed hashes to disk"<<endl;
			} else if (inputNumber == 1) {
				saveOutputToDisk = false;
				diskModeNotSet = false;
				cout<< "System will directly compare computed hashes"<<endl;
			} else {
				cout << "Wrong input!" << endl;
			}
		}
	}

	// count the line in the file
	countLine();

	char* wordlist1;

	// Create a context
	cl::Context context(CL_DEVICE_TYPE_GPU);

	// Get the first device of the context
	std::cout << "Context has " << context.getInfo<CL_CONTEXT_DEVICES>().size()
			<< " devices" << std::endl;
	cl::Device device = context.getInfo<CL_CONTEXT_DEVICES>()[0];
	std::vector<cl::Device> devices;
	devices.push_back(device);
	OpenCL::printDeviceInfo(std::cout, device);

	// Create a command queue
	cl::CommandQueue queue(context, device, CL_QUEUE_PROFILING_ENABLE);

	// Load the source code
	cl::Program program = OpenCL::loadProgramSource(context,
			"src/OpenCLExercise1_Basics.cl");
	// Compile the source code. This is similar to program.build(devices) but will print more detailed error messages
	OpenCL::buildProgram(program, devices);

	// Create a kernel object
	cl::Kernel kernel1(program, "kernel1");

	// Declare some values
	std::size_t wgSize = 256; // Number of work items per work group
	std::size_t count = wgSize *256*256; // Overall number of work items = Number of elements
	if ((size_t)linecount < count)
	{
		count =  (size_t) ((ceil((double) linecount / (double) wgSize))*wgSize);
	}
	printf("count=%lu\n", count);
	std::size_t sizein = count * sizeof(char) * MAX_PW_LENGTH; // Size of data in bytes
	std::size_t sizeout = count * sizeof(uint) * 8; // Size of data in bytes
	std::size_t sizelength = count * sizeof(cl_int); // Size of data in bytes

	//determine how many iterations we need to go through the whole input file
	int numberOfIterations = (int) ceil((double) linecount / (double) count); //4;  ceil expect double
	printf("after ceil: %d\n", numberOfIterations);

	char line[MAX_PW_LENGTH];
	char *wordlist = new char[count * MAX_PW_LENGTH];

	// Allocate space for input data and for output data from CPU and GPU on the host
	std::vector<wordStruct> h_input(count);
	std::vector<outStruct> h_outputCpu(count);
	std::vector<outStruct> h_outputGpu(count);
	std::vector<cl_int> h_length(count);

	// Allocate space for input and output data on the device
	cl::Buffer d_input(context, CL_MEM_READ_WRITE | CL_MEM_ALLOC_HOST_PTR,
			sizein);
	cl::Buffer d_output(context, CL_MEM_READ_WRITE, sizeout);
	cl::Buffer d_length(context, CL_MEM_READ_WRITE, sizelength);

	// Initialize memory to 0xff (useful for debugging because otherwise GPU memory will contain information from last execution)
	memset(h_input.data(), 255, sizein);
	memset(h_outputCpu.data(), 255, sizeout);
	memset(h_outputGpu.data(), 255, sizeout);
	queue.enqueueWriteBuffer(d_input, true, 0, sizein, h_input.data());
	queue.enqueueWriteBuffer(d_output, true, 0, sizeout, h_outputGpu.data());
	queue.enqueueWriteBuffer(d_length, true, 0, sizelength, h_length.data());

	//initial timing variable of GPU
	Core::TimeSpan TotalcopyTime(0);
	Core::TimeSpan TotalGpuExecutionTime(0);
	//Core::TimeSpan TotalGpuTime(0);
	Core::TimeSpan tempTime(0);

	//initial timing event for CPU
	Core::TimeSpan cpuStart = Core::getCurrentTime();
	Core::TimeSpan cpuEnd = Core::getCurrentTime();
	Core::TimeSpan cpuTime[numberOfIterations] = tempTime; //initial cpuTime to currentTime, later will be changed

	//set up buffer of GPU
	kernel1.setArg<cl::Buffer>(0, d_input);
	kernel1.setArg<cl::Buffer>(1, d_output);
	kernel1.setArg<cl::Buffer>(2, d_length);

	//handle the input slice by slice with each slice has count number of password
	for (int i = 0; i < numberOfIterations; i++) {

		//read in password from input file
		wordlist1 = readDataFromFile(line, wordlist, count, (long) count * i,
				(long) count * (i + 1));

		//change the count if it is processing the last slice of data
		if (i == (numberOfIterations - 1)) {
			double temp = fmod((double) linecount , (double) count);
			count = (size_t) (ceil(temp / (double) wgSize) * wgSize);
			printf("count: %zu\n", count);
		}

		//generate input for CPU and GPU
		cout << "initialize Input" << endl;
		for (std::size_t i = 0; i < count; i++) {
			for (int j = 0; j < MAX_PW_LENGTH; j++) {
				h_input[i].word[j] = wordlist1[i * MAX_PW_LENGTH + j];
				h_length[i] = MAX_PW_LENGTH;
			}
		}

		//calculate the hash on both CPU and GPU
		if (GPUoverCPU == 2) {

			//Do calculation on the GPU
			//record the time span on the GPU
			cout << "Starting Iteration on GPU" << endl;
			h_outputGpu = sha256GPU(queue, kernel1, d_input, d_output, d_length,
					h_input, h_length, h_outputGpu, sizein, sizeout, sizelength,
					wgSize, count);
			TotalcopyTime = TotalcopyTime + copyTime;
			TotalGpuExecutionTime = TotalGpuExecutionTime+ gpuTime;

			//Do calculation on the host side
			//record the time span on the CPU
			cout << "Starting Iteration on CPU" << endl;
			cpuStart = Core::getCurrentTime();
			h_outputCpu = sha256(h_input, count, h_outputCpu);
			cpuEnd = Core::getCurrentTime();
			cpuTime[i] = cpuEnd - cpuStart;

			if (saveOutputToDisk) {
				//write the output from GPU to output file
				bool GPUerr = outFile(outputGPU, h_input, count, h_outputGpu);
				if (GPUerr) {
					cout << "GPU file writing complete" << endl<<endl;
				} else {
					cout << "Error while GPU file writing" << endl<<endl;
				}

				//write the output from CPU to output file
				bool CPUerr = outFile(outputCPU, h_input, count, h_outputCpu);
				if (CPUerr) {
					cout << "CPU file writing complete" << endl<<endl;
				} else {
					cout << "Error while CPU file writing" << endl<<endl;
				}
			} else {
				//compare the hash while computing
				if (!foundOnCPU) {
					foundOnCPU = compareOutputHash(h_input, h_outputCpu,
							hashToCrack, "CPU");

				}
				if (!foundOnGPU) {
					foundOnGPU = compareOutputHash(h_input, h_outputGpu,
							hashToCrack, "GPU");
				}
				// if desired hash is founded on both CPU and GPU, stop computing and jump out of for loop
				if (foundOnCPU && foundOnGPU)
				{
					break;
				}

			}

		} else if (GPUoverCPU == 0) {
			// Do calculation on the host side
			//record the time span on the CPU
			cout << "Starting Iteration on CPU" << endl;
			cpuStart = Core::getCurrentTime();
			h_outputCpu = sha256(h_input, count, h_outputCpu);
			cpuEnd = Core::getCurrentTime();
			cpuTime[i] = cpuEnd - cpuStart;

			if (saveOutputToDisk) {
				//write the output from CPU to output file
				bool CPUerr = outFile(outputCPU, h_input, count, h_outputCpu);
				if (CPUerr) {
					cout << "CPU file writing complete" << endl;
				} else {
					cout << "Error while CPU file writing" << endl;
				}

			} else {
				//compare the hash while computing
				if (!foundOnCPU) {
					foundOnCPU = compareOutputHash(h_input, h_outputCpu,
							hashToCrack, "CPU");
				}

				// if desired hash is founded on CPU, stop computing and jump out of for loop
				if (foundOnCPU) {
					break;
				}

			}

		}else if (GPUoverCPU ==1){
			// Do calculation on the GPU side
			//record the time span on the GPU
			cout << "Starting Iteration on GPU" << endl;
			h_outputGpu = sha256GPU(queue, kernel1, d_input, d_output, d_length,
					h_input, h_length, h_outputGpu, sizein, sizeout, sizelength,
					wgSize, count);
			TotalcopyTime = TotalcopyTime + copyTime;
			TotalGpuExecutionTime = TotalGpuExecutionTime + gpuTime;

			if (saveOutputToDisk) {
				//write the output from GPU to output file
				bool GPUerr = outFile(outputGPU, h_input, count, h_outputGpu);
				if (GPUerr) {
					cout << "GPU file writing complete" << endl;
				} else {
					cout << "Error while GPU file writing" << endl;
				}

			} else {
				//compare the hash while computing
				if (!foundOnGPU) {
					foundOnGPU = compareOutputHash(h_input, h_outputGpu,
							hashToCrack, "GPU");
				}
				// if desired hash is founded on GPU, stop computing and jump out of for loop
				if (foundOnGPU) {
					break;
				}
			}
		}

	}

	//if the outputs are saved, compare the desired hash with the data in the output file
	if (saveOutputToDisk) {
		if (GPUoverCPU == 2) {
			compareFile(outputCPU, hashToCrack, "CPU");
			compareFile(outputGPU, hashToCrack, "GPU");
		} else if (GPUoverCPU == 0) {
			compareFile(outputCPU, hashToCrack, "CPU");
		} else if (GPUoverCPU == 1) {
			compareFile(outputGPU, hashToCrack, "GPU");
		}

   }else
        {
         //display the result of not found result
        	if (GPUoverCPU == 2 &&(!foundOnGPU) && (!foundOnCPU)) {
        			cout << "Plaintext is not found on CPU." << endl<< endl;
        			cout << "Plaintext is not found on GPU." << endl<< endl;
        		} else if (GPUoverCPU == 0 && (!foundOnCPU)) {
        			cout << "Plaintext is not found on CPU." << endl<< endl;
        		} else if (GPUoverCPU == 1 && (!foundOnGPU)) {
        			cout << "Plaintext is not found on GPU." << endl<< endl;
        	}
        }

	Core::TimeSpan TotalcpuTime = cpuTime[0];

	// Print performance data
	if (GPUoverCPU==2) {

		// calculate the total CPU time from all the slices
		for (int i = 1; i < numberOfIterations; ++i) {
			TotalcpuTime = TotalcpuTime + cpuTime[i];
		}

		Core::TimeSpan TotaloverallGpuTime = TotalGpuExecutionTime + TotalcopyTime;

		std::cout << "CPU Time: " << TotalcpuTime.toString() << endl;

		std::cout << "Memory copy Time: " << TotalcopyTime.toString()
				<< std::endl;
		std::cout << "GPU Time w/o memory copy: " << TotalGpuExecutionTime.toString()
				<< endl << " (speedup = " << (TotalcpuTime.getSeconds() / TotalGpuExecutionTime.getSeconds()) << ")" << endl;
		std::cout << "GPU Time with memory copy: "
				<< TotaloverallGpuTime.toString() << endl << " (speedup = " << (TotalcpuTime.getSeconds() / TotaloverallGpuTime.getSeconds()) << ")" << endl;

	} else if (GPUoverCPU ==0){
		// calculate the total CPU time from all the slices
		for (int i = 1; i < numberOfIterations; ++i) {
			TotalcpuTime = TotalcpuTime + cpuTime[i];
		}
		std::cout << "CPU Time: " << TotalcpuTime.toString() << endl;

	}else if (GPUoverCPU ==1){
		// calculate the total GPU time
		Core::TimeSpan TotaloverallGpuTime = TotalGpuExecutionTime
				+ TotalcopyTime;
		std::cout << "Memory copy Time: " << TotalcopyTime.toString()
				<< std::endl;
		std::cout << "GPU Time w/o memory copy: "
				<< TotalGpuExecutionTime.toString() << endl;
		std::cout << "GPU Time with memory copy: "
				<< TotaloverallGpuTime.toString() << endl;
	}

	//delete the register for passwords
	delete[] wordlist;

	std::cout << "Success" << std::endl;

	return 0;
}
